<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>ECE 4960 - Dan DiAngelis</title>
        <!-- Favicon-->
        <link rel="icon" type="image/x-icon" href="assets/img/favicon.ico" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v5.13.0/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />
    </head>
    <body id="page-top">
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg bg-dark text-uppercase fixed-top" id="mainNav">
            <div class="container">
                <a class="navbar-brand js-scroll-trigger" href="#page-top">ECE 4960 - Daniel DiAngelis</a>
                <button class="navbar-toggler navbar-toggler-right text-uppercase font-weight-bold bg-dark text-white rounded" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    Menu
                    <i class="fas fa-bars"></i>
                </button>
                <div class="collapse navbar-collapse" id="navbarResponsive">
                    <ul class="navbar-nav ml-auto">
                        <li class="nav-item mx-0 mx-lg-1"><a class="nav-link py-3 px-0 px-lg-3 rounded js-scroll-trigger" href="#portfolio">Labs</a></li>
                        <li class="nav-item mx-0 mx-lg-1"><a class="nav-link py-3 px-0 px-lg-3 rounded js-scroll-trigger" href="#about">About Me</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <!-- Masthead-->
        <header class="masthead bg-primary text-white text-center">
            <div class="container d-flex align-items-center flex-column">
                <!-- Masthead Avatar Image-->
                <!-- <img class="masthead-avatar mb-5" src="assets/img/avataaars.svg" alt="" /> -->
                <!-- Masthead Heading-->
                <h1 class="masthead-heading text-uppercase mb-0">ECE 4960: Fast Robots</h1>
                <!-- Icon Divider-->
                <div class="divider-custom divider-light">
                    <div class="divider-custom-line"></div>
                </div>
                <!-- Masthead Subheading-->
                <p class="masthead-subheading font-weight-light mb-0">Daniel DiAngelis</p>
            </div>
        </header>
        <!-- LAB SECTION-->
        <section class="page-section portfolio" id="portfolio">
            <div class="container">
                <!-- Lab Section Heading-->
                <h2 class="page-section-heading text-center text-uppercase text-dark mb-0">Labs</h2>
                <!-- Icon Divider-->
                <div class="divider-custom">
                    <div class="divider-custom-line"></div>
                </div>
                <!-- Lab Grid Items-->
                <div class="row">
                    <!-- Lab 1-->
                    <div class="col-md-6 col-lg-4 mb-5">
                        <div class="portfolio-item mx-auto" data-toggle="modal" data-target="#portfolioModal1">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"></div>
                            </div>
                            <!--<img class="img-fluid" src="assets/img/portfolio/cabin.png" alt="" />-->
							<p style="font-size:25px">Lab 01 (Artemis)</p>
                        </div>
                    </div>
                    <!-- Lab 2-->
                    <div class="col-md-6 col-lg-4 mb-5">
                        <div class="portfolio-item mx-auto" data-toggle="modal" data-target="#portfolioModal2">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"></div>
                            </div>
							<p style="font-size:25px">Lab 02 (Bluetooth)</p>
                        </div>
                    </div>
                    <!-- Lab 3-->
                    <div class="col-md-6 col-lg-4 mb-5">
                        <div class="portfolio-item mx-auto" data-toggle="modal" data-target="#portfolioModal3">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"></div>
                            </div>
							<p style="font-size:25px">Lab 03 (RC Car Test)</p>
                        </div>
                    </div>
                    
					<!-- Lab 4-->
                    <div class="col-md-6 col-lg-4 mb-5">
                        <div class="portfolio-item mx-auto" data-toggle="modal" data-target="#portfolioModal4">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"></div>
                            </div>
							<p style="font-size:25px">Lab 04 (Open Loop)</p>
                        </div>
                    </div>
                    <!-- Lab 5-->
                    <div class="col-md-6 col-lg-4 mb-5">
                        <div class="portfolio-item mx-auto" data-toggle="modal" data-target="#portfolioModal5">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"></div>
                            </div>
							<p style="font-size:25px">Lab 05 (Obstacle Avoidance)</p>
                        </div>
                    </div>
                    <!-- Lab 6-->
                    <div class="col-md-6 col-lg-4 mb-5">
                        <div class="portfolio-item mx-auto" data-toggle="modal" data-target="#portfolioModal6">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"></div>
                            </div>
                            <p style="font-size:25px">Lab 06 (IMU)</p>
                        </div>
                    </div>
					
					<!-- Lab 7-->
                    <div class="col-md-6 col-lg-4 mb-5">
                        <div class="portfolio-item mx-auto" data-toggle="modal" data-target="#portfolioModal7">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"></div>
                            </div>
                            <p style="font-size:25px">Lab 07 (Odometry)</p>
                        </div>
                    </div>                   
					<!-- Lab 8-->
                    <div class="col-md-6 col-lg-4 mb-5">
                        <div class="portfolio-item mx-auto" data-toggle="modal" data-target="#portfolioModal8">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"></div>
                            </div>
                            <p style="font-size:25px">Lab 08 (Mapping)</p>
                        </div>
                    </div>
					<!-- Lab 9-->
                    <div class="col-md-6 col-lg-4 mb-5">
                        <div class="portfolio-item mx-auto" data-toggle="modal" data-target="#portfolioModal9">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"></div>
                            </div>
                            <p style="font-size:25px">Lab 09 (Localization)</p>
                        </div>
                    </div>
				
					<!-- Lab 10-->
                    <div class="col-md-6 col-lg-4 mb-5">
                        <div class="portfolio-item mx-auto" data-toggle="modal" data-target="#portfolioModal10">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"></div>
                            </div>
                            <p style="font-size:25px">Lab 10 (Planning)</p>
                        </div>
                    </div>
					<!-- Lab 11-->
                    <div class="col-md-6 col-lg-4 mb-5">
                        <div class="portfolio-item mx-auto" data-toggle="modal" data-target="#portfolioModal11">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"></div>
                            </div>
                            <p style="font-size:25px">Lab 11 (PID Control)</p>
                        </div>
                    </div>
					<!-- Lab 12-->
                    <div class="col-md-6 col-lg-4 mb-5">
                        <div class="portfolio-item mx-auto" data-toggle="modal" data-target="#portfolioModal12">
                            <div class="portfolio-item-caption d-flex align-items-center justify-content-center h-100 w-100">
                                <div class="portfolio-item-caption-content text-center text-white"></div>
                            </div>
                            <p style="font-size:25px">Lab 12 (Inverted Pendulum, LQR Control)</p>
                        </div>
                    </div>
				</div>
            </div>
        </section>
        <!-- About Me Section-->
        <section class="page-section bg-primary text-white mb-0" id="about">
            <div class="container">
                <!-- About Section Heading-->
                <h2 class="page-section-heading text-center text-uppercase text-white">About Me</h2>
                <!-- Icon Divider-->
                <div class="divider-custom divider-light">
                    <div class="divider-custom-line"></div>
                </div>
                <!-- About Section Content-->
                    <div class="row">
                    <img class="col-lg-4 ml-auto mb-5" src="assets/img/me.png" alt="" />
                    <div class="col-lg-4 mr-auto"><p class="lead">I am an M.Eng. student in mechanical engineering. I received my undergraduate degree from Rensselaer Polytechnic Institute where I majored in mechanical engineering and minored in electrical engineering. My focus area is in controls and mechatronics, and I look forward to learning more about the hardware and software implementation of control theory. <br>You can reach me at dmd354@cornell.edu</p></div>
                </div>
					
					<p class="text-center  mb-0" style="font-size:20px"></p>
            </div>
        </section>

        

        <!-- Scroll to Top Button (Only visible on small and extra-small screen sizes)-->
        <div class="scroll-to-top d-lg-none position-fixed">
            <a class="js-scroll-trigger d-block text-center text-white rounded" href="#page-top"><i class="fa fa-chevron-up"></i></a>
        </div>
        
		
		
		<!-- Lab Modals-->
		<!-- ______________________________________________________________________________________________________________________________________________________________________ -->
        <!-- Lab Modal 1-->
        <div class="portfolio-modal modal fade" id="portfolioModal1" tabindex="-1" role="dialog" aria-labelledby="portfolioModal1Label" aria-hidden="true">
            <div class="modal-dialog modal-xl" role="document">
                <div class="modal-content">
                    <button class="close" type="button" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true"><i class="fas fa-times"></i></span>
                    </button>
                    <div class="modal-body">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Lab Modal - Title-->
                                    <h2 class="portfolio-modal-title text-dark text-uppercase mb-0 text-center" id="portfolioModal1Label">Lab 01</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                    </div>
									<h3>Abstract</h3>
									<br>
									<p>In this lab, the Arduino IDE was configured to interact with the SparkFun RedBoard Artemis Nano and some of the features of the hardware were tested. A program was also written to have the onboard LED light up when the microphone detected a whistle. In addition to the Arduino IDE, a virtual machine was also configured for future use.</p>									
									<br>
									<h3>Part A: The Artemis Board</h3>
									<br>
									<p>The “Blink!” example was run and the LED was observed to blink as expected. The SVL baud rate did not need to be lowered from the default (921600 baud). The blinking LED can be seen in the video below.</p>									
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/sE-EbIqZAKE" allowfullscreen></iframe>
									</div>
									<br>
									<p>The code for “Example2_Serial” was downloaded to the board to verify that the serial port works. The video below shows the code being downloaded and then communication is done to and from the board in the serial monitor on the right half of the screen.</p>
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/78Omi8RaHZ0" allowfullscreen></iframe>
									</div>
									<br>
									<p>The code for “Example4_analogRead” was downloaded to the board to ensure that the board was able to read analog input from the temperature sensor. The video below shows the analog data being read from the board. During this data collection, the Artemis board was held and breathed on to warm it up. It can be seen that the internal temperature measurement started around 27°C and increased to around 32°C.</p>
									<br>
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/kRN5F9_FWdw" allowfullscreen></iframe>
									</div>
									<br>
									<p>When the “Example1_MicrophoneOutput” code was initially run, the serial monitor printed a seemingly random collection of symbols indicating some sort of communication error. This bad output can be seen below.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab01/bad_output_img.png" alt="" />
									<br>
									<p>To fix this issue, the baud rate on the serial monitor was adjusted to match that specified in the code (115200 baud). The desired output was then printed correctly. The changing loudest frequency value was observed when talking near the board and when loud vehicles would drive past the nearby window. The functionality of this code running on the hardware was further tested using a tone generator found online. This can be seen in the video below where it can be observed that the program detects a range of frequencies reasonably well.</p>
									<br>
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/4t4gaoOknZM" allowfullscreen></iframe>
									</div>
									<br>
									<p>By watching the Loudest Frequency value change while whistling was attempted, an approximate whistle frequency range was determined to be 750Hz to 1500Hz. The “Example1_MicrophoneOutput” code was slightly modified to light the LED when whistling was detected. This was accomplished by first adding the following line to the setup function to set the LED pin to be an output.</p>
									<pre><code>
pinMode(LED_BUILTIN, OUTPUT); // initialize digital pin LED_BUILTIN as an output
									</code></pre>
									<p>Then in the function that prints the loudest frequency, before printing, the frequency is checked to see if it is in the whistle range, and if so, the LED is turned on and a message is printed indicating that a whistle was detected. Otherwise, the LED is turned off, and the normal message is printed. This was accomplished with the following lines of code:</p>
									<pre><code>
if(ui32LoudestFrequency>750 && ui32LoudestFrequency<1500) // if sound is in my whistle range
{
	digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)
	Serial.printf("Loudest frequency: %d    WHISTLE DETECTED\n", ui32LoudestFrequency);
}
else
{
	digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW
	Serial.printf("Loudest frequency: %d         \n", ui32LoudestFrequency);
									</code></pre>
									
									<p>The operation of this code can be seen in the video below. The video also shows that the Artemis board is operating with power from the battery instead of the USB cable.</p>
									<br>
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/GOCP1CXYj44" allowfullscreen></iframe>
									</div>
									
									<br>
									<br>
									<h3>Part B: Virtual Machine Setup</h3>
									<br>
									<p>A virtual machine was added to VirtualBox by copying the provided  OVA file. The image below shows the VirtualBox manager window with the virtual machine to be used in this class selected. The preview window in the image also shows the desktop of the virtual machine to which a Guest Additions CD Image and a shared folder have been added.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab01/virtualbox_img.png" alt="" />
									<br>
                                    <button class="btn btn-dark" data-dismiss="modal">
                                        <i class="fas fa-times fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
		<!-- Lab Modal 2-->
        <div class="portfolio-modal modal fade" id="portfolioModal2" tabindex="-1" role="dialog" aria-labelledby="portfolioModal2Label" aria-hidden="true">
            <div class="modal-dialog modal-xl" role="document">
                <div class="modal-content">
                    <button class="close" type="button" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true"><i class="fas fa-times"></i></span>
                    </button>
                    <div class="modal-body">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Lab Modal - Title-->
                                    <h2 class="portfolio-modal-title text-dark text-uppercase mb-0 text-center" id="portfolioModal2Label">Lab 02</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                    </div>
									<h3>Abstract</h3>
									<br>
									<p>In this lab, bluetooth communication was established between my computer and the artemis board. This came with a large number of challenges, and the host OS had to be used instead of the virtual machine. However, a connection was established, and data was able to be transferred.</p>									
									<br>
									<h3>Connecting to the Artemis Board</h3>
									<br>
									<p>The first few times main.py was run in the virtual machine the following error appeared:</p>									
									<br>
									<img class="img-fluid mb-5" src="Lab02/img/1.png" alt="" />
									<br>
									<p>Then, after unplugging and plugging back in the bluetooth adapter several times, the following error message was printed:</p>
									<br>
									<img class="img-fluid mb-5" src="Lab02/img/2.png" alt="" />
									<br>
									<p>The VM was restarted twice, the USB bluetooth adapter was moved to a different port on the PC, and the board was able to be found. In settings.py, the MAC address was added to Settings["cached"]. When this was done, and main.py was run again, the LED on the Artemis board would blink on and off indicating that a connection had been made.</p>
									<p>Around this point, the Artemis board began to act unresponsive after restarting and was found to be getting stuck on line 136 of the distributed Arduino sketch. This issue fixed itself some time later for no apparent reason, then began acting up the next day only to fix itself again.</p>
									<p>Additionally, at this point running main.py resulted in the following error message.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab02/img/4.png" alt="" />
									<br>
									<p>This error could not be diagnosed, and the rest of the lab was done on the host machine (Windows 10).</p>
									<p>After downloading Python and Bleak on the host OS, main.py was run in the command prompt window. The following errors were found most times the script was run, but after several runs, the board connected. This inconsistency persisted through the rest of the lab.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab02/img/5.png" alt="" />
									<br>
									<h3>Pinging the Robot</h3>
									<br>
									<p>In main.py, <code>pass</code> was commented out and <code>await theRobot.ping()</code> was uncommented. Then main.py was run and the output was observed in the terminal. The terminal displayed round trip times, about 850 of these recorded times were copied and can be seen in the histogram below.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab02/img/6.png" alt="" />
									<br>
									<p>It can be seen that  the largest group of pings took around 100-105ms. The times ranged from 79.8 to 143.6ms and the average time was 101.25ms. The line <code>amdtpsSendData(m_Rcvd, l_Rcvd);</code> in the PING case shows that l_Rcvd is the length of the data being transmitted in the ping. The sketch was modified so that l_Rcvd would be printed in the serial monitor, and it was found to be 99. Therefore, the ping transfers 99 bytes. From this, it was calculated that on average the bluetooth transmission was about 15643 bits per second. This is significantly lower than the serial transmission used in this lab of 115200 baud (115200 bits/sec).</p>
									<br>
									<h3>Requesting a Float</h3>
									<br>
									<p>In main.py, <code>await theRobot.ping()</code> was commented out and <code>await theRobot.sendCommand(Commands.REQ_FLOAT)</code> was uncommented. Then the REQ_FLOAT case in the Arduino sketch was changed to the following:</p>
									<br>
									<pre><code>
case REQ_FLOAT:
	Serial.println("Going to send a float");
	//TODO: Put a float (perhaps pi) into a command response and send it.
	res_cmd->command_type = GIVE_FLOAT;     //set command type as GIVE_FLOAT
	res_cmd->length=6;                      //length doesn't matter since the handler will take care of this
	((float *)(res_cmd->data))[0] = 1.23f;  //put a float into data to send
	amdtpsSendData((uint8_t *)res_cmd, 6);  //2 bytes for type and length, 4 bytes of data
	break;
									</code></pre>
									<br>
									<p>When run, the terminal showed the following output:</p>
									<br>
									<img class="img-fluid mb-5" src="Lab02/img/7.png" alt="" />
									<br>
									<p>The float displayed on the screen didn’t exactly match the float that was sent (1.23). This shows that data transmission over bluetooth isn’t perfect, and if floats are to be compared, the comparisons may not be accurate if the data was transmitted over bluetooth.</p>
									<br>
									<h3>Testing the Data Rate</h3>
									<br>
									<p>To transmit data, the following code was added to the main loop in the arduino sketch:</p>
									<br>
									<pre><code>
if (bytestream_active)
{
	
	res_cmd->command_type = BYTESTREAM_TX;  //set command type to bytestream transmit
	res_cmd->length = 14;                    //length doesn't matter since the handler will take care of this
	//TODO: Put an example of a 32-bit integer and a 64-bit integer
	//for the stream. Be sure to add a corresponding case in the python program.
	//Serial.printf("Stream %d \n", bytestream_active);
	
	((uint32_t *)(res_cmd->data))[0] = 32;  //put a 32 bit integer into data to send (4 bytes)
	
	uint64_t num = 64;
	memcpy(res_cmd->data+4, &num, 8);       //put a 64 bit integer into data to send (8 bytes)


	// send a little data
	//amdtpsSendData((uint8_t *)res_cmd, 14);  //2 bytes for type and length, 12 bytes of data

	// send a lot of data
	uint64_t num2 = 65;
	memcpy(res_cmd->data+12, &num2, 8);       //put a 64 bit integer into data to send (8 bytes)
	uint64_t num3 = 66;
	memcpy(res_cmd->data+20, &num3, 8);       //put a 64 bit integer into data to send (8 bytes)
	uint64_t num4 = 67;
	memcpy(res_cmd->data+28, &num4, 8);       //put a 64 bit integer into data to send (8 bytes)
	uint64_t num5 = 68;
	memcpy(res_cmd->data+36, &num5, 8);       //put a 64 bit integer into data to send (8 bytes)
	uint64_t num6 = 69;
	memcpy(res_cmd->data+44, &num6, 6);       //put a 64 bit integer into data to send (8 bytes)     
	uint64_t num7 = 70;
	memcpy(res_cmd->data+52, &num7, 8);       //put a 64 bit integer into data to send (8 bytes)
	uint64_t num8 = 70;
	memcpy(res_cmd->data+60, &num8, 8);       //put a 64 bit integer into data to send (8 bytes)
	amdtpsSendData((uint8_t *)res_cmd, 70);  //2 bytes for type and length, 68 bytes of data
	
	//Print time
	unsigned long t = micros();
	Serial.printf("Package %d sent at %d us \n", pkg_count, t);
	pkg_count++;
}
									</code></pre>
									<br>
									<p>In addition to this code, bytestream_active was set to 1 in the START_BYTESTREAM_TX case, and pkg count was initialized as a global variable with a value of 0. As it appears, the above code transmits a byte stream of one 32-bit integer and eight 64-bit integers (70-byte command), but if the line under <code>// send a little data</code> is uncommented and the 15 lines under <code>// send a lot of data</code> are commented out, the code will instead only transmit one 32 bit integer and one 64 bit integers (14-byte command). This code also has the board serial print every time a package is sent along with the time that it was sent. </p>
									<br>
									<p>In main.py, <code>await theRobot.sendCommand(Commands.START_BYTESTREAM_TX)</code> was added to myRobotTasks and all other commands were commented out. Additionally the following lines were added to the simpleHandler function:</p>
									<br>
									<pre><code>
if (code == Commands.BYTESTREAM_TX.value):
	print(unpack("&lt;Iqqqqqqqq", data))   #unpacks 1 4-byte int and 8 8-byte int 
									</code></pre>
									<br>
									<p>The code above would print the package sent for the 70 byte command case. For the 14-byte case, <code>"&lt;Iq"</code> was used as the format string to indicate that data only includes one 4-byte number and one 8-byte number.</p>
									<br>
									<p>When the code was run for the 70-byte case, the output on the serial monitor and command line window looked like the following image.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab02/img/out.png" alt="" />
									<br>
									<p>From testing the code for both package cases, the histograms below were made for the amount of time that passed between each package being sent.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab02/img/8.png" alt="" />
									<img class="img-fluid mb-5" src="Lab02/img/9.png" alt="" />
									<br>
									<p>It can be seen that the largest amount of measurements of time was between 10.86 and 11.06ms for the smaller package, and between 11.14 and 11.34ms for the larger package. On average, the 14-byte packages were sent every 11.03ms and the 70-byte packages were sent every 11.16ms. This indicates that the larger packages sent slightly slower. For the 14-byte test, 932 packages were sent, but the terminal only printed 811 of them indicating that about 13% of them were dropped. For the 70-byte test, 904 packages were sent, but the terminal only printed 766 of them indicating that about 15% of them were dropped.</p>
									<br>
                                    <button class="btn btn-dark" data-dismiss="modal">
                                        <i class="fas fa-times fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
		
        <!-- Lab Modal 3-->
        <div class="portfolio-modal modal fade" id="portfolioModal3" tabindex="-1" role="dialog" aria-labelledby="portfolioModal3Label" aria-hidden="true">
            <div class="modal-dialog modal-xl" role="document">
                <div class="modal-content">
                    <button class="close" type="button" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true"><i class="fas fa-times"></i></span>
                    </button>
                    <div class="modal-body">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Lab Modal - Title-->
                                    <h2 class="portfolio-modal-title text-dark text-uppercase mb-0 text-center" id="portfolioModal3Label">Lab 03</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                    </div>
									<h3>Abstract</h3>
									<br>
									<p>In this lab, several observations, measurements, and calculations were made for both the physical remote control car and the simulated robot.</p>							
									<br>
									<h3>Part A: Characterizing the Car</h3>
									<br>
									<p><u>Dimensions</u></p>
									<br>
									<p>Several dimensions were measured at least four times using a pair of digital callipers. The dimensions measured can be found in the image below.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab03/img/dim.png" alt="" />
									<br>
									<p>The averaged measurements were:</p>
									<ul>
										<li>Wheel Diameter: 77.4 mm</li>
										<li>Distance Between Axle Centers: 80.0 mm</li>
										<li>Width: 139.1 mm</li>
										<li>Length: 145.8 mm</li>
									</ul>
									<p>These dimensions may be useful when coming up with a model for the platform. The most useful dimension is most likely the wheel diameter which can be used to determine distance the car will travel per revolution as well as the tangential force that torque on the wheels will cause.</p>
									<br>
									<p><u>Backlash</u></p>
									<br>
									<p>The backlash of the gear train driving the wheels was measured by marking one of the little treads on one wheel with a pencil, and holding that wheel fixed so that the marked tread is the closest to the other wheel. Then the other wheel was turned as far as possible in one direction without straining the system. Then the tread on the turned wheel closest to the already marked tread was also marked. The turned wheel was then turned the opposite direction in a similar manner. From this position, the number of treads between the turning wheels starting and final position were counted. This is diagrammed in the figure below.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab03/img/bl.png" alt="" />
									<br>
									<p>From the knowledge that each wheel has 92 little treads, it was calculated from 4 trials that the backlash is approximately 11.7 degrees. This measurement can only be seen as approximate because of the amount of play in the system and how easily the plastic bent. Knowing that this much backlash exists in the system will be useful since it will add some mechanical delay between the motor turning and the wheels turning.</p>
									<br>
									<p><u>Wheel Speed</u></p>
									<br>
									<p>The speed of the car’s wheels was measured using a slow-motion camera. This was done by securing the car in place, putting tape on one wheel, and comparing that piece of tape’s position to the position of a  stationary piece of tape. A computer with a stopwatch was also placed in the camera’s field of view. The setup for this test can be seen below.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab03/img/speed_setup.png" alt="" />
									<br>
									<p>Slow-motion videos were recorded of both the right and left wheels spinning forward and backwards in both “speedy” and “slowly” modes. These videos can be seen below.</p>
									<br>
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/kG6wfYmQjos" allowfullscreen></iframe>
									</div>
									<br>
									<p>The speed was calculated by using the stopwatch to find the time for the wheel to fully rotate 4 times and averaging the values calculated from two sets of rotations for each case. The rotations chosen were several seconds after the start, and several seconds before the stop of the control input to ensure that the spinning was steady-state. The spinning speed was found to be about 12.9 rev/s in “Slowly” mode and 14.4 rev/s in “Speedy” mode. Although the wheels will turn slower when actually moving the car due to friction and the added load of the car’s weight, this speed can be used to approximate the max speed the car could go.</p>
									<br>
									<p><u>Tricks and Performance</u></p>
									<br>
									<p>Having the car go at full speed in one direction, and then quickly switching the direction momentarily results in the car doing a forward roll as seen in the video below.</p>
									<br>
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/jzS7eQ7KOkk" allowfullscreen></iframe>
									</div>
									<br>
									<p>The car was found to turn reasonably well around its center. The video below shows the car turning in a roughly 9 inch circle of electrical tape in both “speedy” and “slowly” modes.</p>
									<br>
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/Q4GD8aLt4mY" allowfullscreen></iframe>
									</div>
									<br>
									<p>It can be seen that the car can stay in the circle for at least one or two rotations. It tended to drift off to the right, but upon further inspection of the floor, it was found to be slightly inclined. This test shows that an approximation of the car turning about its axis like a unicycle-robot model could be accurate.</p>
									<br>
									<p><u>Summary</u></p>
									<br>
									<p>The values measured and calculated are tabulated below.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab03/img/sum.png" alt="" />
									<br>
									<h3>Part B: Characterizing the Virtual Robot</h3>
									<br>
									<p>All of the steps were followed to install software dependencies, set up the base code, start the simulator, and start the keyboard teleoperation tool. Only one small error was encountered. This error can be found in the picture below and was corrected by simply running the command given in the error message.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab03/img/e1.png" alt="" />
									<br>
									<p>The teleop commands were used to move the robot around. This can be seen in the video below in which the speed is adjusted and the robot is driven around.</p>
									<br>
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/cGGPTknislU" allowfullscreen></iframe>
									</div>
									<br>
									<p>The video shows the following aspects of the simulation environment:</p>
									<ul>
										<li>When the robot collides with a wall a warning triangle appears over the robot, and it stops moving</li>
										<li>Teleoperation works from the perspective view</li>
										<li>The robot could be dragged and dropped with the cursor</li>
										<li>when the robot is placed outside of the maze area and is driven out of the workspace, the workspace extends</li>
									</ul>
									<p>There didn't seem to be lower limits on the speed of the robot as the values could be changed to be arbitrarily small in the terminal and the robot would just move slower and slower. However, the robot seemed to have an upper limit on the linear and angular speed as the value could be increased in the terminal, but the robot would stop accelerating at a certain point. This max speed was measured using the video below in which the input speeds were made very large and the robot was driven straight and rotated.</p>
									<br>
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/mSlhdMmfAW0" allowfullscreen></iframe>
									</div>
									<br>
									<p>By looking at the robot pose and the clock at various times, the maximum linear speed was calculated to be 1 unit/sec and the maximum angular speed was calculated to be 90 deg/sec.</p>
									<br>
                                    <button class="btn btn-dark" data-dismiss="modal">
                                        <i class="fas fa-times fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
		<!-- Lab Modal 4-->
        <div class="portfolio-modal modal fade" id="portfolioModal4" tabindex="-1" role="dialog" aria-labelledby="portfolioModal4Label" aria-hidden="true">
            <div class="modal-dialog modal-xl" role="document">
                <div class="modal-content">
                    <button class="close" type="button" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true"><i class="fas fa-times"></i></span>
                    </button>
                    <div class="modal-body">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Lab Modal - Title-->
                                    <h2 class="portfolio-modal-title text-dark text-uppercase mb-0 text-center" id="portfolioModal4Label">Lab 04</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                    </div>
									<h3>Abstract</h3>
                                    <br>
									<p>In this lab, the Artemis board was connected to the motors of the car through the motor driver and open loop control was implemented. Open loop control was also explored in the simulation environment.</p>
									<br>
									<h3>Part A: Hardware Open Loop Control</h3>
									<br>
									<p>The artemis board was connected to the motor driver, and “Example1_wire” was run to find the address of the driver. The address was found to be 0x5D which matches the the default address shown on <a href="https://learn.sparkfun.com/tutorials/hookup-guide-for-the-qwiic-motor-driver?_ga=2.14725942.1279742571.1601299911-1939484602.1599657570#software-setup">Sparkfun’s website</a>.</p>
									<br>
									<p>Taking apart the car involved four sets of screws. The locations of these screws is diagrammed below.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab04/img/screw.png" alt="" />
									<br>
									<p>Instead of cutting the power cables from the control PCB like some kind of barbarian, I desoldered them.</p>
									<p>To route the Qwiic connector cable from inside the car to the artemis board, the hole where the power button was actuated through was drilled out to a 5/16th inch hole. This hole can be seen below.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab04/img/hole.png" alt="" />
									<br>
									<p>The motor driver was connected to the motors and battery and its placement inside the car can be seen below.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab04/img/inside.png" alt="" />
									<br>
									<p>The gray cover for the button piece was cut in half and put over the drilled hole to keep a classy look. The Artemis Board and its battery were then taped to the outside of the car to keep them temporarily secured, but still easily accessible. The assembled car can be seen below.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab04/img/assembled_car.png" alt="" />
									<br>
									<p>The examples\MotorTest code was modified for use in this lab. The I2C address in the code was changed to match that of the motor driver.</p>
									<p>The minimum value for which the motors would turn was found by using the code below and seeing on the serial window at what input the wheels started to turn.</p>
									<br>
									<pre><code>
//set motor constants
#define L_MOTOR 0
#define R_MOTOR 1
#define FWD 0
#define REV 1
void loop()
{
  //***** Operate the Motor Driver *****//
  //  It uses .setDrive( motorName, direction, level ) to drive the motors.

  for (int i = 50; i &lt; 70; i++)
  {
    Serial.printf("Right Side, current input: %d\n", i);
    myMotorDriver.setDrive( R_MOTOR, FWD, i);
    delay(1000);
  }
  myMotorDriver.setDrive( R_MOTOR, FWD, 0);
  
  for (int i = 50; i &lt; 70; i++)
  {
    Serial.printf("Left Side, current input: %d\n", i);
    myMotorDriver.setDrive( L_MOTOR, FWD, i);
    delay(1000);
  }
  myMotorDriver.setDrive( L_MOTOR, FWD, 0);
}
									</code></pre>
									<br>
									<p>The wheels were found to turn  at rather inconsistent values, but by averaging several values, the wheels were found to turn around an input of 59 (σ=1.2) for the left side, and 54 (σ=2.0) for the right side. This of course is dependent on how fresh the battery is, and with a slightly used battery the values were found to be 64 (σ=4.0) and 59 (σ=1.2). It was also found that both wheels would turn at much lower inputs if given a little nudge. The important takeaway here is that inputs below 70 should probably be avoided unless the wheels are already turning in that direction.</p>
									<p>The following lines were found on the <a href="https://learn.sparkfun.com/tutorials/hookup-guide-for-the-qwiic-motor-driver?_ga=2.14725942.1279742571.1601299911-1939484602.1599657570#software-setup">Sparkfun page</a> and added to the setup code so that the motors would have the same forward direction.</p>
									<br>
									<pre><code>
// motor 1 inversion so that forward is the same for both motors
while ( myMotorDriver.busy() ); //Waits until the SCMD is available.
myMotorDriver.inversionMode(1, 1); //invert motor 1

									</code></pre>
									<br>
									<p>Then the code below was written to test how straight the car drives.</p>
									<br>
									<pre><code>
//set motor constants
#define L_MOTOR 0
#define R_MOTOR 1
#define FWD 0
#define REV 1
void loop()
{
  //***** Operate the Motor Driver *****//
  //  It uses .setDrive( motorName, direction, level ) to drive the motors.

  //Set both motors going forward at a medium speed for some time
  myMotorDriver.setDrive( L_MOTOR, FWD, 100);
  myMotorDriver.setDrive( R_MOTOR, FWD, 100);
  delay(2400);
  //Turn off both motors
  myMotorDriver.setDrive( L_MOTOR, FWD, 0);
  myMotorDriver.setDrive( R_MOTOR, FWD, 0);

  while(1); //stop after one run
}
									</code></pre>
									<br>
									<p>The following video shows the above code running when the car is placed on a straight piece of tape that has perpendicular pieces of tape that indicate 6 feet.</p>
									<br>
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/P11lz3kDZ8M" allowfullscreen></iframe>
									</div>
									<br>
									<p>It can be seen that at the end of 6 feet, the car is consistently still partially overlapping with the tape. This shows that the car can go pretty straight without a calibration factor.</p>
									<p>The code below was then written to demonstrate open loop control.</p>
									<br>
									<pre><code>
  for (int i = 0; i &lt; 4; i++) //run through these commands 4 times
  {
    //drive forward for a bit
    myMotorDriver.setDrive( L_MOTOR, FWD, 80);
    myMotorDriver.setDrive( R_MOTOR, FWD, 80);
    delay(1000);
    
    //Turn Right for a bit
    myMotorDriver.setDrive( L_MOTOR, FWD, 200);
    myMotorDriver.setDrive( R_MOTOR, REV, 200);
    delay(1500);
  
    //drive backward for a bit
    myMotorDriver.setDrive( L_MOTOR, REV, 100);
    myMotorDriver.setDrive( R_MOTOR, REV, 100); 
    delay(800);

    //Turn Left for a bit
    myMotorDriver.setDrive( L_MOTOR, REV, 200);
    myMotorDriver.setDrive( R_MOTOR, FWD, 200);
    delay(1000);
  }
  
  // stop motors
  myMotorDriver.setDrive( L_MOTOR, REV, 0);
  myMotorDriver.setDrive( R_MOTOR, REV, 0); 

  while(1); //stop
									</code></pre>
									<br>
									<p>The code includes commands to drive and turn in all directions at various speeds for various times. The code running on the robot can be seen in the video below.</p>
									<br>
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/4aPx2wvLV3Y" allowfullscreen></iframe>
									</div>
									<br>
									<h3>Part B: Simulation Open-Loop Control</h3>
									<br>
									<p>Before starting this part, the VM hard disk space was expanded to 16 GB, and the provided Jupyter Lab tutorial was followed.</p>
									<p>The base code was set up, and the Jupyter Lab Notebook was started. By running all of the code blocks in the notebook and playing around with the code in the Move the Robot section, the basic function of the Robot class was understood.</p>
									<p>The following code was written to have the robot follow a roughly rectangular loop.</p>
									<br>
									<pre><code>
steps = 12 # number of steps to take (3 times around the square)
step = 0 # current step
while step &lt; steps:

    #rotate at 90deg/sec for 1 second
    robot.set_vel(0,1.5708) # rotate 
    time.sleep(1)

    #go foward for a bit
    robot.set_vel(.5,0) 
    time.sleep(2)
    
#stop robot
robot.set_vel(0,0)
									</code></pre>
									<br>
									<p>The code works by having the robot turn at 90 deg/sec for 1 second to turn a right angle, and then going forward for two seconds. By looping these two commands, a square path was created. This operation assumes that the angular velocity control is the exact speed that the robot moves. This wouldn’t work as well on a physical system, since the angular velocity couldn’t be controlled with such accuracy.</p>
									<p>The operation of the code can be seen in the video below.</p>
									<br>
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/Hbhm3FdBvPc" allowfullscreen></iframe>
									</div>
									<br>
									<p>Footprints were turned on so that the path would be more clear. It can be seen that the robot follows a very square path. </p>
									<br>
                                    <button class="btn btn-dark" data-dismiss="modal">
                                        <i class="fas fa-times fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
		
        <!-- Lab Modal 5-->
        <div class="portfolio-modal modal fade" id="portfolioModal5" tabindex="-1" role="dialog" aria-labelledby="portfolioModal5Label" aria-hidden="true">
            <div class="modal-dialog modal-xl" role="document">
                <div class="modal-content">
                    <button class="close" type="button" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true"><i class="fas fa-times"></i></span>
                    </button>
                    <div class="modal-body">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Lab Modal - Title-->
                                    <h2 class="portfolio-modal-title text-dark text-uppercase mb-0 text-center" id="portfolioModal5Label">Lab 05</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <h3>Abstract</h3>
									<br>
                                    <p>In this lab, the functionality of the proximity sensor and time of light sensor were explored. Then obstacle avoidance code was implemented on the physical and simulated robot.</p>
									<br>
                                    <h3>Part A: Hardware Obstacle Avoidance</h3>
									<br>
									<p>The following default I2C addresses were found on the datasheets for the two sensors used in this lab:</p>
									<ul>
										<li>VCNL4040 Proximity Sensor: 0x60</li>
										<li>VL53L1X Time of Flight (ToF) Sensor: 0x52</li>
									</ul>
                                    <p>The proximity sensor has a range of 0-200mm with no dead zone and SparkFun claims that this sensor is better for detecting qualitative detection than distance measurements. The ToF sensor has a range of 40-400mm. Because of this, I plan on mounting both sensors on the front of the car and using the proximity sensor for distance measurements less than 4cm from the car, and the ToF sensor for all other distance measurements.</p>
                                    <p>Because of this proposed setup, the robot will be unable to detect any objects not directly in front of it.</p>
                                    <p>The following table discusses several distance sensors based on infrared transmission. This information in this table was found in the <a href="https://cei-lab.github.io/ECE4960/lectures/FastRobots-3-Sensors.pdf">Lecture 3 Slides</a>.</p>
									<br>
                                    <img class="img-fluid mb-5" src="Lab05/img/ir_table.png" alt="" />
									<br>
                                    <p>The Arduino library manager was used to uninstall the libraries for both sensors.</p>
									<br>
                                    <p><u>Proximity Sensor</u></p>
									<br>
                                    <p>By running Example1_wire the I2C address of the proximity sensor was found to be 0x60. This matches what is specified on the datasheet.</p>
                                    <p>The image below shows the setup used to map the sensor readings to actual distances.</p>
									<br>
                                    <img class="img-fluid mb-5" src="Lab05/img/prox_setup.png" alt="" />
									<br>
                                    <p>The items in the following image were used to test the proximity sensor. There is the box that the Artemis components came in that is shiny and red, a stack of post-it notes that is white and flat, and a book that has a black and bumpy cover.</p>
									<br>
                                    <img class="img-fluid mb-5" src="Lab05/img/targets.png" alt="" />
									<br>
                                    <p>The results from testing the sensor in two different lighting conditions can be found below. The first lighting condition was the normal amount of light I have in my apartment when working which I would expect to be the typical operating condition for the robot, and the second condition was with the lights off and blinds closed since the robot may end up under furniture where it is dark.</p>
									<br>
                                    <img class="img-fluid mb-5" src="Lab05/img/prox_plots.png" alt="" />
									<br>
									<p>The black target resulted in the weakest measurements, and the lighting condition seemed to have very little effect on the results.</p>
                                    <p>The main loop was changed to just be the following to find out how long it takes to read a value:</p>
									<br>
                                    <pre><code>
unsigned long t0 = micros(); // start time
unsigned int proxValue = proximitySensor.getProximity();
unsigned long delt = micros() - t0;
Serial.println(delt);
									</code></pre>
									<br>
                                    <p>It was found that it takes about 630 μs (σ=0.76) to read the sensor value.</p>
									<br>
                                    <p><u>Time of Flight Sensor</u></p>
									<br>
                                    <p>By running Example1_wire the I2C address of the ToF sensor was found to be 0x29. This does not match the default specified on the datasheet, but the datasheet does specify that the address is programmable so it can be changed.</p>
                                    <p>The ToF sensor was found to need calibration, so Example7_Calibration was run. It was found that this code didn’t work as provided. <code>startRanging()</code> and <code>stopRanging()</code> commands had to be added to the code that looks for a low distance to initialize the calibration. Once this was done, the calibration code worked.</p>
                                    <p>Since the robot has a maximum speed around 2.7m/s as found in Lab 3, taking a distance reading every 55 ms would result in the robot having 15cm of space to react after seeing something. Because of the ToF sensor’s large range, this seemed like a reasonable range, so the timing budget was set to 50, and the inter measurement period was set to 5 with the following lines put into the setup code.</p>
									<br>
									<pre><code>
distanceSensor.setTimingBudgetInMs(50);
distanceSensor.setIntermeasurementPeriod(5);
									</code></pre>
									<br>
                                    <p>Based on the max speed of 2.7m/s it was determined that the robot could cover the max range distances in the following times:</p>
									<ul>
										<li>Short (1.3m): 0.481s</li>
										<li>Medium (3m): 1.11s</li>
										<li>Long (4m): 1.48s</li>
									</ul>
                                    <p>For the application of obstacle avoidance, half a second to react to an obstacle seemed sufficient, so the minimum distance mode was set so that the robot could get really close to obstacles:</p>
									<br>
                                    <pre><code>
distanceSensor.setDistanceModeShort();
									</code></pre>
									<br>
                                    <p>When Example3_StatusAndRate was run, it was found that when an object would move rapidly in front of the sensor, the range status would change to Wrapped target fail and occasionally sigma fail. This means that the sensor measurements may not be as accurate when the car is going fast or there are fast moving obstacles around it.</p>
                                    <p>The following code was used to test the sensor:</p>
									<br>
                                    <pre><code>
void setup(void)
{
  Wire.begin();

  Serial.begin(115200);
  Serial.println("VL53L1X Qwiic Test");
  //VL53L1_SetInterMeasurementPeriodMilliSeconds(&amp;VL53L1Dev, 1000 );
  if (distanceSensor.begin() != 0) //Begin returns 0 on a good init
  {
    Serial.println("Sensor failed to begin. Please check wiring. Freezing...");
    while (1)
      ;
  }
  Serial.println("Sensor online!");
  distanceSensor.setTimingBudgetInMs(50);
  distanceSensor.setIntermeasurementPeriod(5);
  distanceSensor.setDistanceModeShort();
  distanceSensor.startRanging(); //just continue ranging the whole time to save time
}

void loop(void)
{
  long startTime = millis();
  while (!distanceSensor.checkForDataReady())
  {
    delay(1);
  }
  int distance = distanceSensor.getDistance(); //Get the result of the measurement from the sensor
  distanceSensor.clearInterrupt();
  long endTime = millis();
  Serial.print("Distance(mm): ");
  Serial.print(distance);

  float distanceInches = distance * 0.0393701;
  float distanceFeet = distanceInches / 12.0;

  Serial.print("\tDistance(ft): ");
  Serial.print(distanceFeet, 2);
  Serial.print("\tRanger time: ,");
  Serial.print((float)(endTime - startTime), 2);

  Serial.println();
}
									</code></pre>
									<br>
                                    <p>The time for one ranger measurement was found, on average, to be 44.9ms (σ=1.18).</p>
									<br>
									<p>By using a similar setup to that used for the proximity sensor, data was found for a range of distances. This time instead of using the white post-it notes, the gray target that came with the kit was used. This was only done in normal lighting conditions. The data is plotted below.</p>
									<br>
                                    <img class="img-fluid mb-5" src="Lab05/img/tof_plots.png" alt="" />
									<br>
                                    <p>The sensor was fairly accurate between 40 and 600mm the worst measurement was found to be 13% off of the true value for the gray target, 16% for the red target, and 32% for the black target. Once again, the black, bumpy target results in the worst data.</p>
									<p>To test the range capabilities with these settings, the sensor was pointed at a wall and moved away from it until it was no longer able to take readings (returned 0 instead of a value). With these settings this occurred around 2.06m.</p>
									<br>
                                    <p><u>Obstacle Avoidance</u></p>
									<br>
                                    <p>To mount the sensors on the car, a cardboard “bumper” was made for the front of the car. Another cardboard “bumper” was made for the back of the car which has a slot to hold the Artemis Board’s battery. These Cardboard components can be seen below.</p>
									<br>
                                    <img class="img-fluid mb-5" src="Lab05/img/bumpers.png" alt="" />
									<br>
                                    <p>The car assembled with the sensors can be seen below.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab05/img/car.png" alt="" />
									<br>
                                    <p>It was found that the ToF sensor would occasionally detect the floor and think it was an obstacle, so some tape was added to slightly angle the sensors upwards:</p>
									<br>
                                    <img class="img-fluid mb-5" src="Lab05/img/tape.png" alt="" />
									<br>
                                    <p>The following code was written to test how fast the robot could go and still stop before hitting an obstacle.</p>
									<br>
									<pre><code>
#include &lt;Arduino.h&gt;
#include &lt;stdint.h&gt;
#include "SCMD.h"
#include "SCMD_config.h" //Contains #defines for common SCMD register names and values
#include &lt;ComponentObject.h&gt;
#include &lt;RangeSensor.h&gt;
#include &lt;SparkFun_VL53L1X.h&gt;
#include &lt;vl53l1x_class.h&gt;
#include &lt;vl53l1_error_codes.h&gt;
#include &lt;Wire.h&gt;
#include "SparkFun_VL53L1X.h" //Click here to get the library: http://librarymanager/All#SparkFun_VL53L1X

//Optional interrupt and shutdown pins.
#define SHUTDOWN_PIN 2
#define INTERRUPT_PIN 3

SCMD myMotorDriver; //This creates the main object of one motor driver and connected slaves.

SFEVL53L1X distanceSensor;
//Uncomment the following line to use the optional shutdown and interrupt pins.
//SFEVL53L1X distanceSensor(Wire, SHUTDOWN_PIN, INTERRUPT_PIN);

void setup(void)
{
  Serial.begin(115200);
  //motor setup
  myMotorDriver.settings.commInterface = I2C_MODE;
  myMotorDriver.settings.I2CAddress = 0x5D; //config pattern is "1000" (default) on board for address 0x5D
  myMotorDriver.settings.chipSelectPin = 10;
  //*****initialize the driver get wait for idle*****//
  while ( myMotorDriver.begin() != 0xA9 ) //Wait until a valid ID word is returned
  {
    Serial.println( "ID mismatch, trying again" );
    delay(500);
  }
  Serial.println( "ID matches 0xA9" );
  //  Check to make sure the driver is done looking for slaves before beginning
  Serial.print("Waiting for enumeration...");
  while ( myMotorDriver.ready() == false );
  // motor 1 inversion so that foward is the same for both motors
  while ( myMotorDriver.busy() ); //Waits until the SCMD is available.
  myMotorDriver.inversionMode(1, 1); //invert motor 1
  while ( myMotorDriver.busy() );
  myMotorDriver.enable();

  // sensor setup  
  Wire.begin();

  Serial.println("VL53L1X Qwiic Test");
  //VL53L1_SetInterMeasurementPeriodMilliSeconds(&amp;VL53L1Dev, 1000 );
  if (distanceSensor.begin() != 0) //Begin returns 0 on a good init
  {
    Serial.println("Sensor failed to begin. Please check wiring. Freezing...");
    while (1)
      ;
  }
  Serial.println("Sensor online!");
  distanceSensor.setTimingBudgetInMs(50);
  distanceSensor.setIntermeasurementPeriod(5);
  distanceSensor.setDistanceModeShort();
  distanceSensor.startRanging(); //just continue ranging the whole time to save time turning it on/off
}

//set motor constants
#define L_MOTOR 0
#define R_MOTOR 1
#define FWD 0
#define REV 1

void loop(void)
{
  while (!distanceSensor.checkForDataReady())
  {
    delay(1);
  }
  int distance = distanceSensor.getDistance(); //Get the result of the measurement from the sensor
  distanceSensor.clearInterrupt();

  //Serial.print("Distance(mm): ");
  //Serial.print(distance);
  
  byte rangeStatus = distanceSensor.getRangeStatus();
  if(rangeStatus==0)  //only act if sensor reading was good
  {
    if(distance==0 || distance&gt;300) //0 if there is no object nearby
    {
      //drive straight
      myMotorDriver.setDrive( L_MOTOR, FWD, 125);
      myMotorDriver.setDrive( R_MOTOR, FWD, 125);
    }
    else
    {
      // hit the breaks!
      myMotorDriver.setDrive( L_MOTOR, REV, 255);
      myMotorDriver.setDrive( R_MOTOR, REV, 255);
      delay(300);
      //stop motors
      myMotorDriver.setDrive( L_MOTOR, REV, 0);
      myMotorDriver.setDrive( R_MOTOR, REV, 0);
      while(1); //wait for reset
    }
  }

  //Serial.println();
}
                                    </code></pre>
									<br>
                                    <p>Through trial and error, it was found that a control input of 125 was pretty much the fastest I could have the robot go without it just running into things and still respond relatively close to obstacles. To stop the robot, a brief reverse control input is applied to stop the robot from coasting.</p>
                                    <p>The code running on the robot can be seen in the video below.</p>
									<br>
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/coF3KKbDAUs" allowfullscreen></iframe>
									</div>
									<br>
									<p>The robot can be seen to consistently stop itself before hitting the wall.</p>
									<p>The main loop in the code above was changed so that when the robot detected an obstacle, it would stop turn, and continue going:</p>
									<br>
									<pre><code>
void loop(void)
{
  while (!distanceSensor.checkForDataReady())
  {
    delay(1);
  }
  int distance = distanceSensor.getDistance(); //Get the result of the measurement from the sensor
  distanceSensor.clearInterrupt();

  //Serial.print("Distance(mm): ");
  //Serial.print(distance);
  
  byte rangeStatus = distanceSensor.getRangeStatus();
  if(rangeStatus==0)  //only act if sensor reading was good
  {
    if(distance==0 || distance>300) //0 if there is no object nearby
    {
      myMotorDriver.setDrive( L_MOTOR, FWD, 120);
      myMotorDriver.setDrive( R_MOTOR, FWD, 120);
    }
    else
    {
      // hit the breaks
      myMotorDriver.setDrive( L_MOTOR, REV, 225);
      myMotorDriver.setDrive( R_MOTOR, REV, 225);
      delay(200);
  
      //turn
      myMotorDriver.setDrive( L_MOTOR, FWD, 200);
      myMotorDriver.setDrive( R_MOTOR, REV, 200);
      delay(300);
    }
  }
}
									</code></pre>
									<br>
									<p>This code can be seen running in the following video.</p>
									<br>
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/3PwE_AU0N28" allowfullscreen></iframe>
									</div>
									<br>
									<p>The robot does a pretty good job at detecting and avoiding large objects, but when there are narrower objects or objects that aren’t directly in front of it, it doesn't detect them, and sometimes runs into them.</p>
									<p>In an attempt to get the robot to detect narrower obstacles, the proximity sensor reading was added to the object detection code as follows. </p>
									<br>
									<pre><code>
void loop(void)
{
  while (!distanceSensor.checkForDataReady())
  {
    delay(1);
  }
  int distance = distanceSensor.getDistance(); //Get the result of the measurement from ToF sensor
  unsigned int proxValue = proximitySensor.getProximity();  //Get result from prox sensor
  distanceSensor.clearInterrupt();

  /*
  Serial.print("Distance(mm): ");
  Serial.print(distance);
  Serial.print("\tProx: ");
  Serial.print(proxValue);
  Serial.print("\n");
  */
  
  byte rangeStatus = distanceSensor.getRangeStatus();
  if(rangeStatus==0)  //only act if sensor reading was good
  {
    if((distance==0 || distance&gt;300) &amp;&amp; proxValue&lt;20) //0 if there is no object nearby
    {
      myMotorDriver.setDrive( L_MOTOR, FWD, 120);
      myMotorDriver.setDrive( R_MOTOR, FWD, 120);
    }
    else
    {
      // hit the breaks
      myMotorDriver.setDrive( L_MOTOR, REV, 225);
      myMotorDriver.setDrive( R_MOTOR, REV, 225);
      delay(200);
  
      //turn
      myMotorDriver.setDrive( L_MOTOR, FWD, 200);
      myMotorDriver.setDrive( R_MOTOR, REV, 200);
      delay(300);
    }
  }
									</code></pre>
									<br>
									<p>Appropriate setup for the proximity sensor was also added to the code. This addition did not make a dramatic difference on the robot's obstacle avoidance, and its operation can be seen as slightly improved from before in the following video.</p>
									<br>
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/WzgIKMxdG5U" allowfullscreen></iframe>
									</div>
									<br>
									<p>Given more time, further experimentation could have been done on where the sensors are placed on the robot as well as tuning of the speed and detection threshold values to improve the robot's performance.</p>
									<br>
									<br>
                                    <h3>Part B: Simulation Obstacle Avoidance</h3>
									<br>
                                    <p>The same setup process used in the previous lab was used to set up the simulation and jupyter  notebook.</p>
									<br>
                                    <p>To have the simulated robot avoid obstacles code was written to have the robot go forward until it is close to an obstacle, turn, and then continue moving forward. This code can be seen below.</p>
									<br>
									<pre><code>
def perform_obstacle_avoidance(robot):
    turn_dir = 1
    while True:
        # Obstacle avoidance code goes here
        dist = robot.get_laser_data() # find distance measurement
        while(dist>0.3):
            robot.set_vel(0.7,0) # drive foward while there is no close obstacle
            turn_dir = -turn_dir # keep fliping sign of turn direction to get more random paths
            dist = robot.get_laser_data() # find distance measurement
        # turn 90 deg when object is detected
        robot.set_vel(0,turn_dir*1.5708) # rotate at 90 deg/sec
        time.sleep(1) # continue rotating for 1 sec       
           
perform_obstacle_avoidance(robot)
									</code></pre>
									<br>
                                    <p>The code has the robot turn at 90 degree angles because it was found that if the robot stays perpendicular or parallel to the walls is much less likely to collide with them. When smaller angle turns were made collisions were found to occur when the robot would be driving nearly parallel to a wall, and slowly crash into it. The code I wrote also has a variable <code>turn_dir</code> that controls the sign of the angular speed command given to the robot. This variable is continuously flipped between +1 and -1 when the robot is going forward. The result of this is that when the robot detects that it is close to an obstacle, it will turn in an approximately random direction. This was implemented so that the robot doesn’t just get stuck in a boring rectangular pattern.</p>
                                    <p>Through trial and error it was found that a linear speed of 0.7 and sensor distance to stop going forward of 0.3 result in the robot going as fast as possible and getting as close to the walls as possible while consistently avoiding collisions. For linear speed of 0.8 or distance of 0.2. The robot was found to crash. The operation of the code can be seen in the following video.</p>
									<br>
                                    <div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/8-auIhNTbOE" allowfullscreen></iframe>
									</div>
									<br>
                                    <p>It can be seen that the robot does a good job of avoiding collisions for a decent amount of time. However it was found that given enough time, the robot drifts away from the desired horizontal and vertical directions and crashes as seen at the end of the video.</p>
									<br>
									
                                    <button class="btn btn-dark" data-dismiss="modal">
                                        <i class="fas fa-times fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Lab Modal 6-->
        <div class="portfolio-modal modal fade" id="portfolioModal6" tabindex="-1" role="dialog" aria-labelledby="portfolioModal6Label" aria-hidden="true">
            <div class="modal-dialog modal-xl" role="document">
                <div class="modal-content">
                    <button class="close" type="button" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true"><i class="fas fa-times"></i></span>
                    </button>
                    <div class="modal-body">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Lab Modal - Title-->
                                    <h2 class="portfolio-modal-title text-dark text-uppercase mb-0 text-center" id="portfolioModal6Label">Lab 06</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <h3>Abstract</h3>
									<br>
									<p></p>
									<br>
									<h3>Part A: IMU, PID, and Odometry</h3>
									<br>
									<p><u>Setting up the IMU</u></p>
									<br>
									<p>By running Example1_wire the I2C address of the proximity sensor was found to be 0x69. This matches what is specified on<a href="https://www.sparkfun.com/products/15335">Sparkfun’s website</a>.</p>
									<p>The Example1_Basics code was run to observe the change in sensor values. When still, the acceleration was found to return about 1000mg for whichever axis was vertical, and around 0mg for the other two axes. When moving back and forth, the accelerometer values would change. When rotating the gyroscope values would change from the nearly zero values that they rest when not moving.</p>
									<br>
									<p><u>Accelerometer</u></p>
									<br>
									<p>The main loop of Example1_Basics was changed to the following to print the pitch and roll values calculated from the accelerometer. <code>math.h</code> was included, and global variables were defined for pitch and roll.</p>
									<br>
									<pre><code>
void loop() {
  
  if( myICM.dataReady() ){
    myICM.getAGMT();                // The values are only updated when you call 'getAGMT'
    pitch_a = atan2(myICM.accX(),myICM.accZ())*180/M_PI;
    Serial.print("\nPitch = ");
    printFormattedFloat( pitch_a, 3, 2 ); 
    roll_a = atan2(myICM.accY(),myICM.accZ())*180/M_PI;
    Serial.print(",\tRoll = ");
    printFormattedFloat( roll_a, 3, 2 );   
    delay(30);
  }
  else{
    Serial.println("Waiting for data");
    delay(500);
  }
}
									</code></pre>
									<br>
									<p>The table below shows the accelerometer positioning and sample readings for rolls and pitches of -90°, 0°, and 90°.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab06/img/table.png" alt="" / />
									<br>
									<p>It can be seen that the measured values were always within 6° of the expected values of ±90° and within 2° of the expected values of 0°. This shows that the readings are fairly accurate, and should be good enough for use without calibration (especially with the uncertainty associated with the levelness of my desk).</p>
									<p>To collect data from the sensor being tapped the following code was written to print the x acceleration.</p>
									<br>
									<pre><code>
void loop() {
  unsigned long t0 = micros(); // start time
  if( myICM.dataReady() ){    
    myICM.getAGMT();                // The values are only updated when you call 'getAGMT'
    printFormattedFloat( myICM.accX(), 5, 3 );
    Serial.print(",");
    unsigned long delt = micros() - t0;    
    printFormattedFloat( delt, 5, 2 );  // print time between measurements to approximate sampling frequency
    Serial.print("\n");
  }
  else{
    Serial.println("Waiting for data");
    delay(500);
  }
}
									</code></pre>
									<br>
									<p>Since I don’t currently have a python IDE installed on my computer, I used MATLAB to plot the frequency response of the accelerometer being tapped several times. The MATLAB code is copied below, and the frequency response plot is below that.</p>
									<br>
									<pre><code>
data = table2array(readtable('tap_data.csv'));
Ts = mean(data(:,2))*(10^-6); % average sampling time in seconds
Fs = 1/Ts;  % sampling frequency

X = data(:,1);  % accelerometer data

% plot(X)         % check raw data
% X = X(1:end);   %trim data

L = length(X);  % Length of data
Y = fft(X); % compute Fourier Transform

% Compute the two-sided spectrum P2. Then compute the single-sided spectrum P1 based on P2 and the even-valued signal length L.
P2 = abs(Y/L);
P1 = P2(1:L/2+1);
P1(2:end-1) = 2*P1(2:end-1);

f = Fs*(0:(L/2))/L; % frequency vector
plot(f,P1) 
title('Single-Sided Amplitude Spectrum of X(t)')
xlabel('f (Hz)')
ylabel('|P1(f)|')
									</code></pre>
									<br>
									<img class="img-fluid mb-5" src="Lab06/img/freq_resp.png" alt="" / />
									<br>
									<p>Although the plot is very noisy, several of the highest peaks are seen to occur at frequencies higher than 190Hz. Using a low-pass filter with a frequency around here should eliminate some of the sensor noise. For the LPF, ⍺ was calculated to be around 0.9 from the equations given in class. The LPF was implemented with the following code.</p>
									<br>
									<pre><code>
if( myICM.dataReady() ){
  myICM.getAGMT();                // The values are only updated when you call 'getAGMT'
  pitch_a = atan2(myICM.accX(),myICM.accZ())*180/M_PI;
  Serial.print("\n");
  Serial.print(pitch_a);
  Serial.print("\t");
  pitch_a_LPF = alpha*pitch_a+(1-alpha)*old_pitch_a;
  old_pitch_a = pitch_a_LPF;
  Serial.print(pitch_a_LPF);
  Serial.print("\t");
  
  roll_a = atan2(myICM.accY(),myICM.accZ())*180/M_PI;
  Serial.print(roll_a);
  Serial.print("\t");
  roll_a_LPF = alpha*roll_a+(1-alpha)*old_roll_a;
  old_roll_a = roll_a_LPF;
  Serial.print(roll_a_LPF);
  Serial.print("\t");
    
    delay(30);
    
}

									</code></pre>
									<br>
									<p>The alpha value of 0.9 was found to not really reduce the noise in the signal, so the value was lowered to 0.3 which did a much better job of making the signal smooth. However, this also made the measurement lag a little more. Some sample data from the serial plotter can be found below. The filtered readings (red and yellow) are significantly less noisy.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab06/img/LPF_serial.png" alt="" / />
									<br>
									<p><u>Gyroscope<u/></p>
									<br>
									<p>Code was added to calculate roll, pitch and yaw with the gyroscope:</p>
									<br>
									<pre><code>
if( myICM.dataReady() )
{
    t0 = micros();
    myICM.getAGMT();                // The values are only updated when you call 'getAGMT'
    
    Serial.print("\n");
    
    //---------------------roll---------------------
    roll_a = -atan2(myICM.accY(),myICM.accZ())*180/M_PI;//flip sign to be consistent with gyro data
    Serial.print(roll_a);
    Serial.print("\t");
    roll_a_LPF = alpha*roll_a+(1-alpha)*old_roll_a;
    old_roll_a = roll_a_LPF;
    Serial.print(roll_a_LPF);
    Serial.print("\t");
    roll_g = roll_g-myICM.gyrX()*(float)dt/1000000;  
    Serial.print(roll_g);
    Serial.print("\t");
    //---------------------pitch---------------------
    pitch_a = atan2(myICM.accX(),myICM.accZ())*180/M_PI;
    Serial.print(pitch_a);
    Serial.print("\t");
    pitch_a_LPF = alpha*pitch_a+(1-alpha)*old_pitch_a;
    old_pitch_a = pitch_a_LPF;
    Serial.print(pitch_a_LPF);
    Serial.print("\t");
    pitch_g = pitch_g-myICM.gyrY()*(float)dt/1000000;
    Serial.print(pitch_g);
    Serial.print("\t");
    //---------------------yaw---------------------
    yaw_g = yaw_g-myICM.gyrZ()*(float)dt/1000000;
    Serial.print(yaw_g); 
    */
    delay(30);
    dt = (micros()-t0); //step size in microseconds
}
									</code></pre>
									<br>
									<p>The plots below show a comparison between the accelerometer pitch reading (blue), the filtered accelerometer pitch reading (red), and the gyroscope reading (green). The plot on the left shows the results when the sensor isn't moved and the plot on the right shows the results when the sensor is rotated.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab06/img/pitch.png" alt="" / />
									<br>
									<p>The gyroscope gives a much less noisy reading, but drifts significantly. Similar results were obtained for roll:</p>
									<br>
									<img class="img-fluid mb-5" src="Lab06/img/roll.png" alt="" / />
									<br>
									<p>Changing the sampling frequency did not seem to have a significant effect on the measured values. I would attribute this to the way I calculate the step size in my code based on whatever step size actually occurs. </p>
									<p>A complimentary filter was implemented to fuse the two sensor readings:</p>
									<br>
									<code><pre>
if( myICM.dataReady() ){
	t0 = micros();
	myICM.getAGMT();                // The values are only updated when you call 'getAGMT'

	Serial.print("\n");
	//---------------------roll---------------------
	roll_a = -atan2(myICM.accY(),myICM.accZ())*180/M_PI;//flip sign to be consistent with gyro data
	roll_a_LPF = 0.2*roll_a+(1-0.2)*old_roll_a;
	old_roll_a = roll_a_LPF;
	roll_g = roll_g-myICM.gyrX()*(float)dt/1000000;
	roll = (old_roll+roll_g*dt/1000000)*(1-alpha)+roll_a_LPF*alpha;
	old_roll = roll;
	Serial.print(roll);
	Serial.print("\t");

	//---------------------pitch---------------------
	pitch_a = atan2(myICM.accX(),myICM.accZ())*180/M_PI;
	pitch_a_LPF = 0.2*pitch_a+(1-0.2)*old_pitch_a;
	old_pitch_a = pitch_a_LPF;
	pitch_g = pitch_g-myICM.gyrY()*(float)dt/1000000;
	pitch = (old_pitch+pitch_g*dt/1000000)*(1-alpha)+pitch_a_LPF*alpha;
	old_pitch = pitch;
	Serial.print(pitch);
	Serial.print("\t");

	//---------------------yaw---------------------
	yaw_g = yaw_g-myICM.gyrZ()*(float)dt/1000000;
	//Serial.print(yaw_g); 

	delay(30);
	dt = (micros()-t0); //step size in microseconds
}
									</code></pre>
									<br>
									<p>It was found that by pre-filtering the accelerometer with an alpha value of 0.2, and then using the complimentary filter a signal with minimal noise and drift was obtained. This signal can be seen in the video below which shows the serial plot with the sensor being moved around tapped, and then left still.</p>
									<br>
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/XkI8FWk9KR4" allowfullscreen></iframe>
									</div>
									<br>
									<p><u>Magnetometer</u></p>
									<br>
									<p>The following lines were adapted from the lab instructions to calculate yaw from the magnetometer.</p>
									<br>
									<pre><code>
xm = myICM.magX()*cos(pitch*M_PI/180)-myICM.magY()*sin(roll*M_PI/180)*sin(pitch)+myICM.magZ()*cos(roll*M_PI/180)*sin(pitch*M_PI/180); //these were saying theta=pitch and roll=phi
ym = myICM.magY()*cos(roll*M_PI/180) + myICM.magZ()*sin(roll*M_PI/180);
yaw = atan2(ym, xm)*180/M_PI;
Serial.print(yaw);
Serial.print("\t");
									</code></pre>
									<br>
									<p>The sensor was rotated until the reading was around 0° to find North. The sensor orientation when facing north can be seen below. In the picture my keyboard is approximately parallel with the wall of my apartment.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab06/img/north.png" alt="" / />
									<br>
									<p>The yaw value was found to be somewhat robust against small changes in roll and pitch especially if those small angle changes were along the axis perpendicular to the North-South direction.</p>
									<br>
									<p><u>PID Control</u></p>
									<br>
									<p>Code from Labs 2, 5, and 6 were combined to enable all of the sensors, bluetooth, and the motors. The handler in main.py was modified to take the data that I wanted to observe:</p>
									<br>
									<pre><code>
if (code == Commands.BYTESTREAM_TX.value):
    print(unpack("&lt;LBBff", data))   #unpacks 1 long, 2 chars and 2 floats
									</code></pre>
									<br>
									<p>The following code was implemented in the arduino sketch to send the current time, motor values, z-axis gyroscope reading, and yaw value to my PC via Bluetooth.</p>
									<br>
									<pre><code>
if (bytestream_active)
{
	res_cmd->command_type = BYTESTREAM_TX;  //set command type to bytestream transmit
	res_cmd->length = 14;                    //length doesn't matter since the handler will take care of this
	//TODO: Put an example of a 32-bit integer and a 64-bit integer
	//for the stream. Be sure to add a corresponding case in the
	//python program.
	//Serial.printf("Stream %d \n", bytestream_active);
	 
	// pack up data to send
	unsigned long t=micros(); //send current time for x axis
	memcpy(res_cmd->data, &t, 4); 
	memcpy(res_cmd->data+4, &L_motor_val, 1);
	memcpy(res_cmd->data+5, &R_motor_val, 1);
	memcpy(res_cmd->data+6, &gyro_z, 4);
	memcpy(res_cmd->data+10, &yaw_g, 4);    
	amdtpsSendData((uint8_t *)res_cmd, 16);  //2 bytes for type and length, 14 bytes of data
}
									</code></pre>
									<br>
									<p>The code below was written to have the robot ramp up the control input to turn around its axis and then ramp back down while collecting yaw data.</p>
									<br>
									<pre><code>
  counts++; //increment counts
  if(counts>200)
  {
    // if its time for the next motor value, increase/decrease it
    if(increase)
    {
      L_motor_val++;
      R_motor_val++;
    }
    else
    {
      L_motor_val--;  //decrease speed
      R_motor_val--;
    }
    counts=0;
    if(L_motor_val==255||L_motor_val==0)
    {
      increase = !increase; //switch direction if cant increase anymore
    }
  }
  //set motors
  myMotorDriver.setDrive( L_MOTOR, FWD, L_motor_val);
  myMotorDriver.setDrive( R_MOTOR, REV, R_motor_val);
  
  if( myICM.dataReady() )
  {
    t0 = micros();
    myICM.getAGMT();                // The values are only updated when you call 'getAGMT'
    
    //---------------------yaw---------------------
    gyro_z = myICM.gyrZ();  //z measurement from gyroscope (angular speed)
    yaw_g = yaw_g-gyro_z*(float)dt/1000000;
    }
  else{
    Serial.println("Waiting for data");
    delay(500);
  }
									</code></pre>
									<br>
									<p>Around this point the connectors for one of my batteries broke so I had to take some time to solder that back together:</p>
									<br>
									<img class="img-fluid mb-5" src="Lab06/img/broke.png" alt="" / />
									<br>
									<p></p>
									<br>
									<p></p>
									<br>
									<p></p>
									<br>
									<p></p>
									<br>
									<p></p>
									<br>
									<p></p>
									<br>
									<p></p>
									<br>
									<p></p>
									<br>
									<p></p>
									<br>
									<p></p>
									<br>
									<p></p>
									<br>
									<p></p>
									<br>
									<p></p>
									<br>
									<p></p>
									<br>
									<p></p>
									<br>
									<p></p>
									<br>
									<h3>Part B: Odometry and Ground Truth in the Virtual Robot</h3>
									<br>
									<p>The following code was written to test the <code>.get_pose()</code> and <code>.get_gt_pose()</code> functions.</p>
									<br>
									<code><pre>
# Use this data cell to test the member functions
od_pose = robot.get_pose()
gt_pose = robot.get_gt_pose()
print('Odometer pose = ({:.3f}, {:.3f}, {:.3f})\n'.format(od_pose[0], od_pose[1], od_pose[2]))
print('Ground truth pose = ({:.3f}, {:.3f}, {:.3f})\n'.format(gt_pose[0], gt_pose[1], gt_pose[2]))
									</code></pre>
									<br>
									<p>The code below was used to plot trajectories based on odometry and ground truth.</p>
									<br>
									<code><pre>
def update_plot(robot):
    # read odometer and plot
    od_pose = robot.get_pose() 
    robot.send_to_plot(od_pose[0], od_pose[1], ODOM)
    
    # read ground truth and plot
    gt_pose = robot.get_gt_pose()
    robot.send_to_plot(gt_pose[0], gt_pose[1], GT)

while 1: # infinite loop
    update_plot(robot)
    time.sleep(.5)# delay
									</code></pre>
									<br>
									<p>Data was sent to the plotter every 0.5 seconds. This resulted in a reasonable amount of data being plotted so that the trajectory of the robot would be obvious, but not too many points would be plotted.</p>
									<p>Plotting while the robot is driven around can be seen in the following video</p>
									<br>
									<div class="embed-responsive embed-responsive-16by9">
										<iframe class="embed-responsive-item" src="https://www.youtube.com/embed/xkcqVJylMWs" allowfullscreen></iframe>
									</div>
									<br>
									<p>The video shows that the odometry position is roughly similar to the ground truth position, but there is significant offset as well as significant noise and drift in the odometry position.</p>
									<br>
									<p>By having the robot follow a circular path for about three minutes, the following plot was obtained.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab06/img/circle3min.png" alt="" />
									<br>
									<p>The ground truth points show a perfect circular pattern, but the odometer shows a noisy cloud of points.</p>
									<p>When the robot was left stationary for some time the following plot was obtained.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab06/img/stationary.png" alt="" />
									<br>
									<p>The ground truth point remains still, but the odometry position drifts and moves about significantly.</p>
									<p>The robot was driven in a straight line at three different speeds to obtain the following results.</p>
									<br>
									<img class="img-fluid mb-5" src="Lab06/img/varyspeed.png" alt="" />
									<br>
									<p>It can be seen that a higher speed results in a straighter line from the odometry reading. This is probably because the reading has less time to drift.</p>
									<br>
                                    <button class="btn btn-dark" data-dismiss="modal">
                                        <i class="fas fa-times fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
		
		<!-- Lab Modal 7-->
		<div class="portfolio-modal modal fade" id="portfolioModal7" tabindex="-1" role="dialog" aria-labelledby="portfolioModal7Label" aria-hidden="true">
            <div class="modal-dialog modal-xl" role="document">
                <div class="modal-content">
                    <button class="close" type="button" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true"><i class="fas fa-times"></i></span>
                    </button>
                    <div class="modal-body">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Lab Modal - Title-->
                                    <h2 class="portfolio-modal-title text-dark text-uppercase mb-0 text-center" id="portfolioModal7Label">Lab 07</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Lab Modal - Image-->
                                    <!--<img class="img-fluid rounded mb-5" src="assets/img/portfolio/cabin.png" alt="" />-->
                                    <!-- Lab Modal - Text-->
                                    <p class="mb-5">Coming soon...</p>
                                    <button class="btn btn-dark" data-dismiss="modal">
                                        <i class="fas fa-times fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
		
		<!-- Lab Modal 8-->
		<div class="portfolio-modal modal fade" id="portfolioModal8" tabindex="-1" role="dialog" aria-labelledby="portfolioModal8Label" aria-hidden="true">
            <div class="modal-dialog modal-xl" role="document">
                <div class="modal-content">
                    <button class="close" type="button" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true"><i class="fas fa-times"></i></span>
                    </button>
                    <div class="modal-body">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Lab Modal - Title-->
                                    <h2 class="portfolio-modal-title text-dark text-uppercase mb-0 text-center" id="portfolioModal8Label">Lab 08</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Lab Modal - Image-->
                                    <!--<img class="img-fluid rounded mb-5" src="assets/img/portfolio/cabin.png" alt="" />-->
                                    <!-- Lab Modal - Text-->
                                    <p class="mb-5">Coming soon...</p>
                                    <button class="btn btn-dark" data-dismiss="modal">
                                        <i class="fas fa-times fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
		
		<!-- Lab Modal 9-->
		<div class="portfolio-modal modal fade" id="portfolioModal9" tabindex="-1" role="dialog" aria-labelledby="portfolioModal9Label" aria-hidden="true">
            <div class="modal-dialog modal-xl" role="document">
                <div class="modal-content">
                    <button class="close" type="button" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true"><i class="fas fa-times"></i></span>
                    </button>
                    <div class="modal-body">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Lab Modal - Title-->
                                    <h2 class="portfolio-modal-title text-dark text-uppercase mb-0 text-center" id="portfolioModal9Label">Lab 09</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Lab Modal - Image-->
                                    <!--<img class="img-fluid rounded mb-5" src="assets/img/portfolio/cabin.png" alt="" />-->
                                    <!-- Lab Modal - Text-->
                                    <p class="mb-5">Coming soon...</p>
                                    <button class="btn btn-dark" data-dismiss="modal">
                                        <i class="fas fa-times fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
		
		<!-- Lab Modal 10-->
		<div class="portfolio-modal modal fade" id="portfolioModal10" tabindex="-1" role="dialog" aria-labelledby="portfolioModal10Label" aria-hidden="true">
            <div class="modal-dialog modal-xl" role="document">
                <div class="modal-content">
                    <button class="close" type="button" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true"><i class="fas fa-times"></i></span>
                    </button>
                    <div class="modal-body">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Lab Modal - Title-->
                                    <h2 class="portfolio-modal-title text-dark text-uppercase mb-0 text-center" id="portfolioModal10Label">Lab 10</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Lab Modal - Image-->
                                    <!--<img class="img-fluid rounded mb-5" src="assets/img/portfolio/cabin.png" alt="" />-->
                                    <!-- Lab Modal - Text-->
                                    <p class="mb-5">Coming soon...</p>
                                    <button class="btn btn-dark" data-dismiss="modal">
                                        <i class="fas fa-times fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
		
		<!-- Lab Modal 11-->
		<div class="portfolio-modal modal fade" id="portfolioModal11" tabindex="-1" role="dialog" aria-labelledby="portfolioModal11Label" aria-hidden="true">
            <div class="modal-dialog modal-xl" role="document">
                <div class="modal-content">
                    <button class="close" type="button" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true"><i class="fas fa-times"></i></span>
                    </button>
                    <div class="modal-body">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Lab Modal - Title-->
                                    <h2 class="portfolio-modal-title text-dark text-uppercase mb-0 text-center" id="portfolioModal11Label">Lab 11</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Lab Modal - Image-->
                                    <!--<img class="img-fluid rounded mb-5" src="assets/img/portfolio/cabin.png" alt="" />-->
                                    <!-- Lab Modal - Text-->
                                    <p class="mb-5">Coming soon...</p>
                                    <button class="btn btn-dark" data-dismiss="modal">
                                        <i class="fas fa-times fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
		
		<!-- Lab Modal 12-->
		<div class="portfolio-modal modal fade" id="portfolioModal12" tabindex="-1" role="dialog" aria-labelledby="portfolioModal12Label" aria-hidden="true">
            <div class="modal-dialog modal-xl" role="document">
                <div class="modal-content">
                    <button class="close" type="button" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true"><i class="fas fa-times"></i></span>
                    </button>
                    <div class="modal-body">
                        <div class="container">
                            <div class="row justify-content-center">
                                <div class="col-lg-8">
                                    <!-- Lab Modal - Title-->
                                    <h2 class="portfolio-modal-title text-dark text-uppercase mb-0 text-center" id="portfolioModal12Label">Lab 12</h2>
                                    <!-- Icon Divider-->
                                    <div class="divider-custom">
                                        <div class="divider-custom-line"></div>
                                    </div>
                                    <!-- Lab Modal - Image-->
                                    <!--<img class="img-fluid rounded mb-5" src="assets/img/portfolio/cabin.png" alt="" />-->
                                    <!-- Lab Modal - Text-->
                                    <p class="mb-5">Coming soon...</p>
                                    <button class="btn btn-dark" data-dismiss="modal">
                                        <i class="fas fa-times fa-fw"></i>
                                        Close Window
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
		
        <!-- Bootstrap core JS-->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.bundle.min.js"></script>
        <!-- Third party plugin JS-->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.4.1/jquery.easing.min.js"></script>
        <!-- Contact form JS-->
        <script src="assets/mail/jqBootstrapValidation.js"></script>
        <script src="assets/mail/contact_me.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
    </body>
</html>
